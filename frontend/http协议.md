## HTTP/1.0

1996 年 5 月 http1.0 发布
首先，任何格式的数据都可以发送，使得互联网不仅可以传输图像、视频、二进制文件。
其次，除了 GET 命令之外，还引入的 POST 命令和 HEAD 命令，丰富了浏览器和服务器的互动手段。
再次，HTTP 请求和回应的格式也变了，除了数据部分，每次通信都要包括头信息，用来描述一些元数据。
其他的新增功能还包括状态码，多字符支持，多部分发送，权限，缓存，内容编码等。
请求格式
下面是 1.0 版本的 HTTP 请求的例子。
GET/HTTP/1.0
User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10*10_5)
Accept: */\_
可以看到，这个格式和 0.9 版本有很大区别，第一行是请求命令，必须在尾部添加协议版本，后面就是多行的头信息，描述客户端情况

回应格式
服务器的回应如下
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84
/n

<html>
  <body>Hello World</body>
</html>
回应的格式是"头信息 + 一个空行（\r\n） + 数据"。其中，第一行是"协议版本 + 状态码（status code） + 状态描述"。

Content-Type 字段
关于字符串的编码，1.0 版本规定，头信息必须是 ASCII 码，后面的数据可以是任何格式，因此服务器在回应的时候必须告诉客户端，数据时什么格式，这就是 Content-Type 的作用，常见的 Content-Type 的值如下。

text/plain
text/html
text/css
image/jpeg
image/png
text/svg+xml
audio/mp4
video/mp4
application/javascript
application/pdf
application/zip
application/atom+xml
这些数据类型总称为 MIME type，每个值都包括一级类型和二级类型，中间用斜杠分割。
有了预定义的类型，厂商也可以自定义类型，
MIME Type 也可以再尾部使用分号，添加参数，
Content-Type:text/html;UTF-8
表明传输的是网页，编码是 UTF-8.
客户端请求的时候可以使用 Accept 字段表明自己可以接受哪些数据格式。

## HTTP1.1

持久链接
1.1 最大的变化，就是引入了持久连接，即 TCP 默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive.
客户端和服务器发现对方一段时间没有活动，就会主动关闭连接，但是规范的做法应该是客户端在最后一个请求是，发送 connection：close，明确服务器关闭 TCP 连接。
对于同一个域名，大多数浏览器允许同事建立 6 个持久连接。

管道机制
1.1 版本还引入了管道机制，即在同一个 TCp 连接里面，客户端可以同时发送多个请求，进一步解决了 HTTP 的效率问题。
举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求

content-length
一个 TCP 链接现在是可以传送多个回应，这样就需要有一个机制，区分数据包是哪一个回应的，这就是 Content-length 字段的作用，用来声明本次回应的数据长度。

作者：骑着蜗牛去遛狗
链接：https://www.jianshu.com/p/1d3b986b6a08
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## HTTP/2

二进制协议
HTTP/1.1 版的头信息肯定是文本（ASCII 编码），数据体可以是文本也可以是二进制，HTTP/2 是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为“帧”，头信息帧和数据帧。
二进制帧的好处是可以定义额外的帧，HTTP/2 定义了近 10 中帧，也为将来的高级应用打下了基础。
多工
HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。
举例来说，在一个 TCP 连接里面，服务器同时收到了 A 请求和 B 请求，于是先回应 A 请求，结果发现处理过程非常耗时，于是就发送 A 请求已经处理好的部分， 接着回应 B 请求，完成后，再发送 A 请求剩下的部分。
这样双向的、实时的通信，就叫做多工（Multiplexing）。
数据流
因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必 须要对数据包做标记，指出它属于哪个回应。
HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据 流，ID 一律为奇数，服务器发出的，ID 为偶数。
数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM 帧），取消这个数据流。1.1 版取消数据流的唯一方法，就是关闭 TCP 连接。这就是说，HTTP/2 可以取消某一次请求，同时保证 TCP 连接还打开着，可以被其他请求使用。
客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。
头信息压缩
HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。
HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。
服务器推送
HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。
常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析 HTML 源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。
